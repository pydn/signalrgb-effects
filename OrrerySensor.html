<!DOCTYPE html>
<html>
<head>
    <title>Celestial Orrery (Full Effects)</title>
    <meta description="A celestial dance with a sensor-driven sun and keypress ripples. v3.4"/>
    <meta publisher="Concept by Gemini, Adapted by Gemini" />

    <meta property="dataSource" type="sensor" label="Sun: Data Source" default="CPU Temperature" tooltip="Select the sensor to drive the sun's effects."/>
    <meta property="effectThreshold" label="Sun: Effect Start Threshold (%)" type="number" min="0" max="100" default="60" tooltip="The sensor value percentage at which all sun effects (color change, shake, flash) begin."/>
    <meta property="shakeIntensity" label="Sun: Shake Intensity" type="number" min="0" max="10" default="3" tooltip="Controls the maximum amount the sun will shake."/>
    <meta property="flashSpeed" label="Sun: Flash Speed" type="number" min="0" max="20" default="5" tooltip="Controls the speed of the sun's flashing effect."/>
    <meta property="flashBrightness" label="Sun: Flash Brightness" type="number" min="0" max="30" default="15" tooltip="How much brighter the sun gets when it flashes."/>
    
    <meta property="keyRippleOn" label="Ripple: Enable Keypress Effect" type="boolean" default="1"/>
    <meta property="keyRippleColor" label="Ripple: Color" type="color" default="#00ddff"/>
    <meta property="keyRippleSpeed" label="Ripple: Speed" type="number" min="1" max="10" default="4" tooltip="How fast the ripples expand outward."/>
    <meta property="keyRippleSize" label="Ripple: Max Size" type="number" min="10" max="100" default="40" tooltip="How large the ripples get before fading out."/>

    <meta property="sunSize" label="Orrery: Sun Size" type="number" min="10" max="50" default="25" tooltip="Controls the base size of the central star.">
    <meta property="numPlanets" label="Orrery: Number of Planets" type="number" min="0" max="8" default="4" tooltip="The number of planets in the system.">
    <meta property="planetSize" label="Orrery: Planet Size" type="number" min="1" max="30" default="4" tooltip="Controls the average size of the planets.">
    <meta property="orbitSpeed" label="Orrery: Orbit Speed" type="number" min="1" max="10" default="3" tooltip="The overall speed of the orbiting planets.">
    <meta property="showOrbits" label="Orrery: Show Orbital Rings" type="boolean" default="1" tooltip="Toggles the faint rings that show the path of each orbit.">
    <meta property="shootingStarFrequency" label="Orrery: Shooting Star Frequency" type="number" min="0" max="10" default="4" tooltip="How often shooting stars appear. 0 is off.">

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="orreryCanvas" width="320" height="200"></canvas>
</body>

<script>
    //================================================
    // 1. SETUP & INITIALIZATION
    //================================================
    const c = document.getElementById("orreryCanvas");
    const ctx = c.getContext("2d");
    const width = c.width;
    const height = c.height;
    const fixedCenterX = width / 2;
    const fixedCenterY = height / 2;

    const planets = [];
    const shootingStars = [];
    const ripples = []; 

    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpHue(a, b, t) {
        let d = b - a;
        if (d > 180) { d -= 360; } else if (d < -180) { d += 360; }
        return (a + d * t);
    }
    
    function hexToHSL(hex) {
        const [, r, g, b] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) || [];
        const rgb = [r, g, b].map(x => parseInt(x, 16) / 255);
        const max = Math.max(...rgb);
        const min = Math.min(...rgb);
        const l = (max + min) / 2;
        if (max === min) return { h: 0, s: 0, l: Math.round(l * 100) };
        const d = max - min;
        const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        let h;
        const [nr, ng, nb] = rgb;
        if (max === nr) h = (ng - nb) / d + (ng < nb ? 6 : 0);
        else if (max === ng) h = (nb - nr) / d + 2;
        else h = (nr - ng) / d + 4;
        return { h: Math.round(h * 60), s: Math.round(s * 100), l: Math.round(l * 100) };
    }

    function Ripple(x, y, hslColor, speed, maxSize) {
        this.x = x;
        this.y = y;
        this.hsl = hslColor;
        this.speed = speed;
        this.maxSize = maxSize;
        this.radius = 0;
        this.isDead = false;

        this.update = function() {
            this.radius += this.speed;
            if (this.radius >= this.maxSize) {
                this.isDead = true;
            }
        };

        this.draw = function(context) {
            const alpha = 1 - (this.radius / this.maxSize);
            context.fillStyle = `hsla(${this.hsl.h}, ${this.hsl.s}%, ${this.hsl.l}%, ${alpha})`;
            context.beginPath();
            context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            context.fill();
        };
    }

    function Planet(distance, speed, size, color) {
        this.distance = distance; this.speed = speed; this.size = size; this.color = color;
        this.angle = Math.random() * Math.PI * 2;
    }

    function ShootingStar() {
        if (Math.random() > 0.5) {
            this.x = Math.random() * width; this.y = Math.random() > 0.5 ? 0 : height;
        } else {
            this.x = Math.random() > 0.5 ? 0 : width; this.y = Math.random() * height;
        }
        const targetX = fixedCenterX + (Math.random() - 0.5) * 100;
        const targetY = fixedCenterY + (Math.random() - 0.5) * 100;
        const angle = Math.atan2(targetY - this.y, targetX - this.x);
        const speed = Math.random() * 2 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.tail = []; this.tailLength = 20;
    }

    function init() {
        const planetCount = typeof numPlanets !== 'undefined' ? numPlanets : 4;
        const pSize = typeof planetSize !== 'undefined' ? planetSize : 4;
        planets.length = 0;
        
        // UPDATED: Replaced the Lime Green with an Indigo/Violet color.
        const neonPlanetColors = [
            { h: 185, s: 100, l: 55 }, // Neon Cyan
            { h: 320, s: 100, l: 60 }, // Hot Pink/Magenta
            { h: 235, s: 100, l: 60 }, // Electric Blue
            { h: 275, s: 100, l: 58 }, // Vibrant Purple
            { h: 290, s: 100, l: 60 }, // Indigo/Violet
        ];

        for (let i = 0; i < planetCount; i++) {
            const distance = 35 + (i * 15);
            const speed = (0.01 / (i + 1)) * 0.5;
            const sizeVariance = pSize / 2;
            const size = (Math.random() * sizeVariance) + (pSize - sizeVariance / 2);
            
            const color = neonPlanetColors[Math.floor(Math.random() * neonPlanetColors.length)];

            planets.push(new Planet(distance, speed, size, color));
        }
    }

    let currentPlanetCount = -1;
    let currentPlanetSize = -1;
    function checkPlanetConfig() {
        const newPlanetCount = typeof numPlanets !== 'undefined' ? numPlanets : 4;
        const newPlanetSize = typeof planetSize !== 'undefined' ? planetSize : 4;
        if (newPlanetCount !== currentPlanetCount || newPlanetSize !== currentPlanetSize) {
            currentPlanetCount = newPlanetCount;
            currentPlanetSize = newPlanetSize;
            init();
        }
    }

    //================================================
    // 2. EVENT HANDLERS
    //================================================
    let rippleColorHSL = hexToHSL("#00ddff");
    function onkeyRippleColorChanged() {
        if (typeof keyRippleColor !== 'undefined') {
            rippleColorHSL = hexToHSL(keyRippleColor);
        }
    }
    
    function onCanvasTapped(x, y) {
        if (typeof keyRippleOn !== 'undefined' && keyRippleOn) {
            const speed = (typeof keyRippleSpeed !== 'undefined' ? keyRippleSpeed : 4) / 10.0;
            const size = typeof keyRippleSize !== 'undefined' ? keyRippleSize : 40;
            ripples.push(new Ripple(x, y, rippleColorHSL, speed, size));
        }
    }

    //================================================
    // 3. THE UPDATE (RENDER) FUNCTION
    //================================================
    function render() {
        checkPlanetConfig();
        // --- Read properties from UI ---
        const sSize = typeof sunSize !== 'undefined' ? sunSize : 25;
        const oSpeed = typeof orbitSpeed !== 'undefined' ? orbitSpeed : 3;
        const sOrbits = typeof showOrbits !== 'undefined' ? showOrbits : 1;
        const starFreq = typeof shootingStarFrequency !== 'undefined' ? shootingStarFrequency : 4;
        const shakeAmount = typeof shakeIntensity !== 'undefined' ? shakeIntensity : 3;
        const effectStartPercent = typeof effectThreshold !== 'undefined' ? effectThreshold : 60;
        const fSpeed = typeof flashSpeed !== 'undefined' ? flashSpeed : 5;
        const fBrightness = typeof flashBrightness !== 'undefined' ? flashBrightness : 15;

        // --- Get Sensor Data for Sun ---
        const sensorName = typeof dataSource !== 'undefined' ? dataSource : 'CPU Temperature';
        let normalizedValue = 0;
        if (typeof engine !== 'undefined' && typeof engine.getSensorValue === 'function' && sensorName) {
            const sensorData = engine.getSensorValue(sensorName);
            if (sensorData && typeof sensorData.value === 'number') {
                const { min, max, value } = sensorData;
                if (max > min) {
                    normalizedValue = (Math.max(min, Math.min(value, max)) - min) / (max - min);
                }
            }
        }

        // --- Calculate Sun Effect Progress based on Threshold ---
        const effectStartThreshold = effectStartPercent / 100.0;
        let effectProgress = 0;
        if (normalizedValue >= effectStartThreshold) {
            effectProgress = (normalizedValue - effectStartThreshold) / (1.0 - effectStartThreshold);
        }

        // --- Calculate Sun Shake Offset ---
        const currentShake = effectProgress * shakeAmount;
        const offsetX = (Math.random() - 0.5) * currentShake;
        const offsetY = (Math.random() - 0.5) * currentShake;
        const centerX = fixedCenterX + offsetX;
        const centerY = fixedCenterY + offsetY;
        
        // --- Calculate Sun Flash ---
        let flashAmount = 0;
        if (effectProgress > 0) {
            const time = Date.now() * (fSpeed / 1000.0);
            flashAmount = ((Math.sin(time) + 1) / 2) * fBrightness * effectProgress;
        }

        // --- Set Background ---
        ctx.fillStyle = '#050214';
        ctx.fillRect(0, 0, width, height);

        // --- Handle Shooting Stars ---
        if (Math.random() < (starFreq / 100) && shootingStars.length < 5) {
            shootingStars.push(new ShootingStar());
        }
        for (let i = shootingStars.length - 1; i >= 0; i--) {
            const s = shootingStars[i]; s.x += s.vx; s.y += s.vy;
            s.tail.unshift({ x: s.x, y: s.y });
            if (s.tail.length > s.tailLength) { s.tail.pop(); }
            for (let j = 0; j < s.tail.length; j++) {
                const opacity = 1 - (j / s.tailLength);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                ctx.beginPath(); ctx.arc(s.tail[j].x, s.tail[j].y, 5.5, 0, Math.PI * 2); ctx.fill();
            }
            if (s.x < 0 || s.x > width || s.y < 0 || s.y > height) {
                shootingStars.splice(i, 1);
            }
        }

        // --- Calculate Sun's Dynamic Color ---
        const LOW_TEMP_COLOR = { h: 50, s: 95, l: 50 };
        const HIGH_TEMP_COLOR = { h: 0, s: 100, l: 40 };
        let sunH, sunS, sunL;
        sunH = lerpHue(LOW_TEMP_COLOR.h, HIGH_TEMP_COLOR.h, effectProgress);
        sunS = lerp(LOW_TEMP_COLOR.s, HIGH_TEMP_COLOR.s, effectProgress);
        sunL = lerp(LOW_TEMP_COLOR.l, HIGH_TEMP_COLOR.l, effectProgress);
        const finalSunL = sunL + flashAmount;

        // --- Draw the Sun's Core and Halo ---
        const coreSunSize = sSize;
        const sunHalo = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSunSize * 1.5);
        sunHalo.addColorStop(0, `hsla(${sunH}, ${sunS}%, ${finalSunL}%, 0.6)`);
        sunHalo.addColorStop(1, `hsla(${sunH}, ${sunS}%, ${finalSunL - 10}%, 0)`);
        ctx.fillStyle = sunHalo;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = `hsl(${sunH}, ${sunS}%, ${finalSunL}%)`;
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreSunSize, 0, Math.PI * 2);
        ctx.fill();

        // --- Draw Planets and their Orbits ---
        planets.forEach(p => {
            p.angle += p.speed * oSpeed * 0.3;
            const x = fixedCenterX + Math.cos(p.angle) * p.distance;
            const y = fixedCenterY + Math.sin(p.angle) * p.distance;
            if (sOrbits) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(fixedCenterX, fixedCenterY, p.distance, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.fillStyle = `hsl(${p.color.h}, ${p.color.s}%, ${p.color.l}%)`;
            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // --- Update and Draw Keypress Ripples ---
        for (let i = ripples.length - 1; i >= 0; i--) {
            const r = ripples[i];
            r.update();
            r.draw(ctx);
            if (r.isDead) {
                ripples.splice(i, 1);
            }
        }

        window.requestAnimationFrame(render);
    }
    
    init();
    render();
</script>
</html>

### Summary of Changes

The only change was a single line inside the `init()` function within the `neonPlanetColors` array.

* **Removed:** `{ h: 125, s: 100, l: 50 }, // Jarring Lime Green`
* **Added:** `{ h: 290, s: 100, l: 60 }, // Indigo/Violet`

This ensures all planets will now have a cool color tone (cyan, pink, blue, purple, indigo) that clearly contrasts with the warm yellow and red of the sun.