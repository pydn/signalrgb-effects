<!DOCTYPE html>
<html>
<head>
    <title>Celestial Orrery (Audio Visualizer) - Archived</title>
    <meta description="A celestial dance where the central star is a vibrant audio visualizer."/>
    <meta publisher="Concept by Gemini, Adapted by Gemini" />

    <meta property="bassPulseStrength" label="Bass Pulse Strength" type="number" min="0" max="20" default="8" tooltip="Controls how much the sun's core pulses with the beat (low frequencies). 0 to disable.">

    <meta property="sunSize" label="Sun Size" type="number" min="10" max="50" default="25" tooltip="Controls the base size of the central star.">
    <meta property="numPlanets" label="Number of Planets" type="number" min="0" max="8" default="4" tooltip="The number of planets in the system.">
    <meta property="planetSize" label="Planet Size" type="number" min="1" max="30" default="4" tooltip="Controls the average size of the planets.">
    <meta property="orbitSpeed" label="Orbit Speed" type="number" min="1" max="10" default="3" tooltip="The overall speed of the orbiting planets.">
    <meta property="showOrbits" label="Show Orbital Rings" type="boolean" default="1" tooltip="Toggles the faint rings that show the path of each orbit.">
    <meta property="shootingStarFrequency" label="Shooting Star Frequency" type="number" min="0" max="10" default="4" tooltip="How often shooting stars appear. 0 is off.">

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="orreryCanvas" width="320" height="200"></canvas>
</body>

<script>
    //================================================
    // 1. SETUP & INITIALIZATION
    //================================================
    const c = document.getElementById("orreryCanvas");
    const ctx = c.getContext("2d");
    const width = c.width;
    const height = c.height;
    const centerX = width / 2;
    const centerY = height / 2;

    const planets = [];
    const shootingStars = [];

    let visualizerHeights = []; 
    let smoothedBass = 0;

    // NEW: Helper function for linear interpolation
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    // NEW: Helper function to correctly interpolate between hues on the color wheel
    function lerpHue(a, b, t) {
        let d = b - a;
        if (d > 180) { d -= 360; } 
        else if (d < -180) { d += 360; }
        return (a + d * t);
    }


    function Planet(distance, speed, size, color) {
        this.distance = distance; this.speed = speed; this.size = size; this.color = color;
        this.angle = Math.random() * Math.PI * 2;
    }

    function ShootingStar() {
        if (Math.random() > 0.5) {
            this.x = Math.random() * width; this.y = Math.random() > 0.5 ? 0 : height;
        } else {
            this.x = Math.random() > 0.5 ? 0 : width; this.y = Math.random() * height;
        }
        const targetX = centerX + (Math.random() - 0.5) * 100;
        const targetY = centerY + (Math.random() - 0.5) * 100;
        const angle = Math.atan2(targetY - this.y, targetX - this.x);
        const speed = Math.random() * 2 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.tail = []; this.tailLength = 20;
    }

    function init() {
        const planetCount = typeof numPlanets !== 'undefined' ? numPlanets : 4;
        const pSize = typeof planetSize !== 'undefined' ? planetSize : 4;

        planets.length = 0;
        for (let i = 0; i < planetCount; i++) {
            const distance = 35 + (i * 15);
            const speed = (0.01 / (i + 1)) * 0.5;
            const sizeVariance = pSize / 2;
            const size = (Math.random() * sizeVariance) + (pSize - sizeVariance / 2);
            
            const colorRanges = [
                { min: 200, max: 260 }, // Shades of Blue
                { min: 280, max: 340 }  // Shades of Purple to Pink
            ];
            
            const range = colorRanges[Math.floor(Math.random() * colorRanges.length)];
            const hue = Math.random() * (range.max - range.min) + range.min;
            
            const color = { h: hue, s: 100, l: 65 }; 

            planets.push(new Planet(distance, speed, size, color));
        }
    }

    let currentPlanetCount = -1;
    let currentPlanetSize = -1;

    function checkPlanetConfig() {
        const newPlanetCount = typeof numPlanets !== 'undefined' ? numPlanets : 4;
        const newPlanetSize = typeof planetSize !== 'undefined' ? planetSize : 4;
        if (newPlanetCount !== currentPlanetCount || newPlanetSize !== currentPlanetSize) {
            currentPlanetCount = newPlanetCount;
            currentPlanetSize = newPlanetSize;
            init();
        }
    }

    //================================================
    // 2. THE UPDATE (RENDER) FUNCTION
    //================================================
    function render() {
        checkPlanetConfig();
        // --- Read properties from UI ---
        const sSize = typeof sunSize !== 'undefined' ? sunSize : 25;
        const oSpeed = typeof orbitSpeed !== 'undefined' ? orbitSpeed : 3;
        const sOrbits = typeof showOrbits !== 'undefined' ? showOrbits : 1;
        const starFreq = typeof shootingStarFrequency !== 'undefined' ? shootingStarFrequency : 4;
        const bassPulseStr = typeof bassPulseStrength !== 'undefined' ? bassPulseStrength : 8;

        const vizAmplitude = 25;
        const smoothFactor = 0.4;

        // --- Get Audio Data & Process for Beat ---
        let reducedFreq = [];
        let audioLevel = -60;

        if (typeof engine !== 'undefined' && engine.audio) {
            const frequency = new Int8Array(engine.audio.freq);
            reducedFreq = Array.from(frequency).filter((_, index) => index % 4 === 0);
            audioLevel = engine.audio.level || -60;

            const bassFrequencyCount = 4;
            const bassFrequencies = reducedFreq.slice(0, bassFrequencyCount);
            const bassEnergy = bassFrequencies.reduce((sum, val) => sum + Math.abs(val), 0) / bassFrequencyCount;

            smoothedBass += (bassEnergy - smoothedBass) * 0.4;
        }

        // --- Set Background ---
        ctx.fillStyle = '#050214';
        ctx.fillRect(0, 0, width, height);

        // --- Handle Shooting Stars ---
        if (Math.random() < (starFreq / 100) && shootingStars.length < 5) {
            shootingStars.push(new ShootingStar());
        }
        for (let i = shootingStars.length - 1; i >= 0; i--) {
            const s = shootingStars[i]; s.x += s.vx; s.y += s.vy;
            s.tail.unshift({x: s.x, y: s.y});
            if (s.tail.length > s.tailLength) { s.tail.pop(); }
            for (let j = 0; j < s.tail.length; j++) {
                const opacity = 1 - (j / s.tailLength);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                ctx.beginPath(); ctx.arc(s.tail[j].x, s.tail[j].y, 1.5, 0, Math.PI * 2); ctx.fill();
            }
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath(); ctx.arc(s.x, s.y, 10.5, 0, Math.PI * 2); ctx.fill();
            if (s.x < 0 || s.x > width || s.y < 0 || s.y > height) { shootingStars.splice(i, 1); }
        }

        // --- Calculate Sun's Dynamic Color & Size ---
        // MODIFIED: Sun color is now based on audio intensity (level).
        const normalizedLevel = Math.max(0, (audioLevel + 60) / 60); // Normalize volume from 0 to 1

        const LOW_COLOR = { h: 240, s: 90, l: 30 };   // Dark Blue
        const MID_COLOR = { h: 0, s: 90, l: 35 };     // Dark Red
        const HIGH_COLOR = { h: 50, s: 100, l: 40 };  // Dark Yellow/Orange

        let sunH, sunS, sunL;

        if (normalizedLevel < 0.5) {
            // Interpolate from Blue to Red on the lower half of volume
            const t = normalizedLevel * 2;
            sunH = lerpHue(LOW_COLOR.h, MID_COLOR.h, t);
            sunS = lerp(LOW_COLOR.s, MID_COLOR.s, t);
            sunL = lerp(LOW_COLOR.l, MID_COLOR.l, t);
        } else {
            // Interpolate from Red to Yellow on the upper half of volume
            const t = (normalizedLevel - 0.5) * 2;
            sunH = lerpHue(MID_COLOR.h, HIGH_COLOR.h, t);
            sunS = lerp(MID_COLOR.s, HIGH_COLOR.s, t);
            sunL = lerp(MID_COLOR.l, HIGH_COLOR.l, t);
        }
        
        const bassPulse = (smoothedBass / 50) * bassPulseStr;
        const coreSunSize = sSize + bassPulse;

        // --- Draw the Sun's Core and Halo ---
        const sunHalo = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSunSize * 1.5);
        // Use the new dynamic HSL values for the halo
        sunHalo.addColorStop(0, `hsla(${sunH}, ${sunS}%, ${sunL}%, 0.6)`);
        sunHalo.addColorStop(1, `hsla(${sunH}, ${sunS}%, ${sunL - 10}%, 0)`);
        ctx.fillStyle = sunHalo;
        ctx.fillRect(0, 0, width, height);

        // Use the new dynamic HSL values for the core
        ctx.fillStyle = `hsl(${sunH}, ${sunS}%, ${sunL}%)`;
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreSunSize, 0, Math.PI * 2);
        ctx.fill();

        // --- Draw Audio Visualizer Bars ---
        if (reducedFreq.length > 0) {
            if (visualizerHeights.length !== reducedFreq.length) {
                visualizerHeights = new Array(reducedFreq.length).fill(0);
            }

            const absFreq = reducedFreq.map(v => Math.abs(v));
            const min = Math.min(...absFreq);
            const max = Math.max(...absFreq);
            const angleStep = (Math.PI * 2) / reducedFreq.length;
            const barWidth = 3;

            for(let i = 0; i < reducedFreq.length; i++) {
                let targetHeight = 0;
                if (max > min) {
                    const normalizedHeight = (absFreq[i] - min) / (max - min);
                    targetHeight = normalizedHeight * vizAmplitude * 2.5;
                }

                const currentHeight = visualizerHeights[i];
                visualizerHeights[i] = currentHeight + (targetHeight - currentHeight) * smoothFactor;
                const displayHeight = visualizerHeights[i];

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(i * angleStep);
                // The visualizer bars will now follow the sun's color
                const barHue = (sunH + i * 1.5) % 360;
                ctx.fillStyle = `hsl(${barHue}, ${sunS}%, ${sunL + 5}%)`;
                ctx.fillRect(coreSunSize, -barWidth / 2, displayHeight + 2, barWidth);
                ctx.restore();
            }
        }

        // --- Draw Planets and their Orbits ---
        planets.forEach(p => {
            p.angle += p.speed * oSpeed * 0.3;
            const x = centerX + Math.cos(p.angle) * p.distance;
            const y = centerY + Math.sin(p.angle) * p.distance;
            if (sOrbits) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, p.distance, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.fillStyle = `hsl(${p.color.h}, ${p.color.s}%, ${p.color.l}%)`;
            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        window.requestAnimationFrame(render);
    }

    init();
    render();
</script>
</html>