<!DOCTYPE html>
<html>
<head>
    <title>Celestial Orrery (Threshold Effects)</title>
    <meta description="A celestial dance where the central star's color shifts and shakes based on a sensor threshold."/>
    <meta publisher="Concept by Gemini, Adapted by Gemini" />

    <meta property="dataSource" type="sensor" label="Data Source" default="CPU Temperature" tooltip="Select the sensor to drive the effects."/>
    <meta property="effectThreshold" label="Effect Start Threshold (%)" type="number" min="0" max="100" default="60" tooltip="The sensor value percentage at which all effects (color change, shake, flash) begin."/>
    <meta property="shakeIntensity" label="Shake Intensity" type="number" min="0" max="10" default="3" tooltip="Controls the maximum amount the sun will shake."/>
    <meta property="flashSpeed" label="Flash Speed" type="number" min="0" max="20" default="5" tooltip="Controls the speed of the flashing effect."/>
    <meta property="flashBrightness" label="Flash Brightness" type="number" min="0" max="30" default="15" tooltip="How much brighter the sun gets when it flashes."/>
    
    <meta property="sunSize" label="Sun Size" type="number" min="10" max="50" default="25" tooltip="Controls the base size of the central star.">
    <meta property="numPlanets" label="Number of Planets" type="number" min="0" max="8" default="4" tooltip="The number of planets in the system.">
    <meta property="planetSize" label="Planet Size" type="number" min="1" max="30" default="4" tooltip="Controls the average size of the planets.">
    <meta property="orbitSpeed" label="Orbit Speed" type="number" min="1" max="10" default="3" tooltip="The overall speed of the orbiting planets.">
    <meta property="showOrbits" label="Show Orbital Rings" type="boolean" default="1" tooltip="Toggles the faint rings that show the path of each orbit.">
    <meta property="shootingStarFrequency" label="Shooting Star Frequency" type="number" min="0" max="10" default="4" tooltip="How often shooting stars appear. 0 is off.">

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="orreryCanvas" width="320" height="200"></canvas>
</body>

<script>
    //================================================
    // 1. SETUP & INITIALIZATION
    //================================================
    const c = document.getElementById("orreryCanvas");
    const ctx = c.getContext("2d");
    const width = c.width;
    const height = c.height;
    const fixedCenterX = width / 2;
    const fixedCenterY = height / 2;

    const planets = [];
    const shootingStars = [];

    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpHue(a, b, t) {
        let d = b - a;
        if (d > 180) { d -= 360; } else if (d < -180) { d += 360; }
        return (a + d * t);
    }

    function Planet(distance, speed, size, color) {
        this.distance = distance; this.speed = speed; this.size = size; this.color = color;
        this.angle = Math.random() * Math.PI * 2;
    }

    function ShootingStar() {
        if (Math.random() > 0.5) {
            this.x = Math.random() * width; this.y = Math.random() > 0.5 ? 0 : height;
        } else {
            this.x = Math.random() > 0.5 ? 0 : width; this.y = Math.random() * height;
        }
        const targetX = fixedCenterX + (Math.random() - 0.5) * 100;
        const targetY = fixedCenterY + (Math.random() - 0.5) * 100;
        const angle = Math.atan2(targetY - this.y, targetX - this.x);
        const speed = Math.random() * 2 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.tail = []; this.tailLength = 20;
    }

    function init() {
        const planetCount = typeof numPlanets !== 'undefined' ? numPlanets : 4;
        const pSize = typeof planetSize !== 'undefined' ? planetSize : 4;
        planets.length = 0;
        for (let i = 0; i < planetCount; i++) {
            const distance = 35 + (i * 15);
            const speed = (0.01 / (i + 1)) * 0.5;
            const sizeVariance = pSize / 2;
            const size = (Math.random() * sizeVariance) + (pSize - sizeVariance / 2);
            const colorRanges = [{ min: 200, max: 260 }, { min: 280, max: 340 }];
            const range = colorRanges[Math.floor(Math.random() * colorRanges.length)];
            const hue = Math.random() * (range.max - range.min) + range.min;
            const color = { h: hue, s: 100, l: 65 };
            planets.push(new Planet(distance, speed, size, color));
        }
    }

    let currentPlanetCount = -1;
    let currentPlanetSize = -1;
    function checkPlanetConfig() {
        const newPlanetCount = typeof numPlanets !== 'undefined' ? numPlanets : 4;
        const newPlanetSize = typeof planetSize !== 'undefined' ? planetSize : 4;
        if (newPlanetCount !== currentPlanetCount || newPlanetSize !== currentPlanetSize) {
            currentPlanetCount = newPlanetCount;
            currentPlanetSize = newPlanetSize;
            init();
        }
    }

    //================================================
    // 2. THE UPDATE (RENDER) FUNCTION
    //================================================
    function render() {
        checkPlanetConfig();
        // --- Read properties from UI ---
        const sSize = typeof sunSize !== 'undefined' ? sunSize : 25;
        const oSpeed = typeof orbitSpeed !== 'undefined' ? orbitSpeed : 3;
        const sOrbits = typeof showOrbits !== 'undefined' ? showOrbits : 1;
        const starFreq = typeof shootingStarFrequency !== 'undefined' ? shootingStarFrequency : 4;
        const shakeAmount = typeof shakeIntensity !== 'undefined' ? shakeIntensity : 3;
        const effectStartPercent = typeof effectThreshold !== 'undefined' ? effectThreshold : 60;
        const fSpeed = typeof flashSpeed !== 'undefined' ? flashSpeed : 5;
        const fBrightness = typeof flashBrightness !== 'undefined' ? flashBrightness : 15;

        // --- Get Sensor Data ---
        const sensorName = typeof dataSource !== 'undefined' ? dataSource : 'CPU Temperature';
        let normalizedValue = 0;
        if (typeof engine !== 'undefined' && typeof engine.getSensorValue === 'function' && sensorName) {
            const sensorData = engine.getSensorValue(sensorName);
            if (sensorData && typeof sensorData.value === 'number') {
                const { min, max, value } = sensorData;
                if (max > min) {
                    const clampedValue = Math.max(min, Math.min(value, max));
                    normalizedValue = (clampedValue - min) / (max - min);
                }
            }
        }

        // --- Calculate Effect Progress based on Threshold ---
        const effectStartThreshold = effectStartPercent / 100.0;
        let effectProgress = 0;
        if (normalizedValue >= effectStartThreshold) {
            effectProgress = (normalizedValue - effectStartThreshold) / (1.0 - effectStartThreshold);
        }

        // --- Calculate Shake Offset ---
        const currentShake = effectProgress * shakeAmount;
        const offsetX = (Math.random() - 0.5) * currentShake;
        const offsetY = (Math.random() - 0.5) * currentShake;
        const centerX = fixedCenterX + offsetX;
        const centerY = fixedCenterY + offsetY;
        
        // --- Calculate Flash ---
        let flashAmount = 0;
        if (effectProgress > 0) {
            const time = Date.now() * (fSpeed / 1000.0);
            const sinWave = (Math.sin(time) + 1) / 2; // Oscillates 0-1
            flashAmount = sinWave * fBrightness * effectProgress;
        }

        // --- Set Background ---
        ctx.fillStyle = '#050214';
        ctx.fillRect(0, 0, width, height);

        // --- Handle Shooting Stars ---
        if (Math.random() < (starFreq / 100) && shootingStars.length < 5) { shootingStars.push(new ShootingStar()); }
        for (let i = shootingStars.length - 1; i >= 0; i--) {
            const s = shootingStars[i]; s.x += s.vx; s.y += s.vy;
            s.tail.unshift({ x: s.x, y: s.y });
            if (s.tail.length > s.tailLength) { s.tail.pop(); }
            for (let j = 0; j < s.tail.length; j++) {
                const opacity = 1 - (j / s.tailLength);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                ctx.beginPath(); ctx.arc(s.tail[j].x, s.tail[j].y, 1.5, 0, Math.PI * 2); ctx.fill();
            }
            if (s.x < 0 || s.x > width || s.y < 0 || s.y > height) { shootingStars.splice(i, 1); }
        }

        // --- Calculate Sun's Dynamic Color ---
        const LOW_TEMP_COLOR = { h: 50, s: 95, l: 50 };   // Deeper Yellow/Golden
        const HIGH_TEMP_COLOR = { h: 0, s: 100, l: 40 };  // Deep Red
        
        let sunH, sunS, sunL;
        
        // The color progression is now a direct interpolation between yellow and red, driven by effectProgress.
        sunH = lerpHue(LOW_TEMP_COLOR.h, HIGH_TEMP_COLOR.h, effectProgress);
        sunS = lerp(LOW_TEMP_COLOR.s, HIGH_TEMP_COLOR.s, effectProgress);
        sunL = lerp(LOW_TEMP_COLOR.l, HIGH_TEMP_COLOR.l, effectProgress);
        
        // Add the calculated flash to the final lightness
        const finalSunL = sunL + flashAmount;

        // --- Draw the Sun's Core and Halo ---
        const coreSunSize = sSize;
        const sunHalo = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSunSize * 1.5);
        sunHalo.addColorStop(0, `hsla(${sunH}, ${sunS}%, ${finalSunL}%, 0.6)`);
        sunHalo.addColorStop(1, `hsla(${sunH}, ${sunS}%, ${finalSunL - 10}%, 0)`);
        ctx.fillStyle = sunHalo;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = `hsl(${sunH}, ${sunS}%, ${finalSunL}%)`;
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreSunSize, 0, Math.PI * 2);
        ctx.fill();

        // --- Draw Planets and their Orbits ---
        planets.forEach(p => {
            p.angle += p.speed * oSpeed * 0.3;
            const x = fixedCenterX + Math.cos(p.angle) * p.distance;
            const y = fixedCenterY + Math.sin(p.angle) * p.distance;
            if (sOrbits) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(fixedCenterX, fixedCenterY, p.distance, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.fillStyle = `hsl(${p.color.h}, ${p.color.s}%, ${p.color.l}%)`;
            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        window.requestAnimationFrame(render);
    }

    init();
    render();
</script>
</html>