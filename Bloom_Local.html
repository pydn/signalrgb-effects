<head>
    <title>Bloom</title>
    <meta description="Color blooms across your devices. v1.0" />
    <meta publisher="SignalRGB" />

    <!-- Active properties -->
    <meta property="tapOn" label="Tap Effect" type="boolean" default="0" />
    <meta property="tapColor" label="Tap Effect Color" type="color" default="#00ddff" min="0" max="360" />
    <meta property="colorMode" label="Effect Mode" type="combobox" values="Sensor Data,Beach,Contemporary,Cottagecore,Custom,Kawaii,Mondrian,Ocean,Outrun,Rainbow,Retro,Space,Summer,Tetris,Vaporwave" default="Sensor Data"/>
    <meta property="userSensor1" label="Sensor Option" type="sensor" default="CPU Load"/>
    <meta property="speed" label="No-Sensor Speed" type="number" default="50" min="0" max="100">
    <meta property="customColor" label="Custom Color" type="color" default="#00aaff" min="0" max="360" />
    <meta property="colorRange" label="Color Range" type="number" default="20" min="0" max="100">
    <meta property="backColor" label="Background Color" type="color" default="#030303" min="0" max="360" />
    <meta property="backFade" label="Background Fade" type="number" default="50" min="0" max="100">
    <meta property="cycleOn" label="Color Cycle" type="boolean" default="0" />
    <meta property="cycleSpeed" label="Color Cycle Speed" type="number" default="50" min="0" max="100">
</head>
  
<body style="margin: 0; padding: 0; background: #000;">
    <canvas id="exCanvas" width="320" height="200"></canvas>
</body>
  
<script>
    // Canvas initialization
    const canvas = document.getElementById('exCanvas');
    const ctx = canvas.getContext('2d');

    // Create a hidden canvas
    const hiddenCanvas = document.createElement('canvas');
    hiddenCanvas.width = 320;
    hiddenCanvas.height = 200;
    // Don't attach to DOM
    const hiddenCtx = hiddenCanvas.getContext('2d');

    const width = 320;
    const height = 200;
    let effects = [];
    let gSensor = 0
    let frontCycle = 0
   
    //#region Update
    function update() {
      if(effects.length < 1) effects.push(new drawDots())

      if(cycleOn) frontCycle += cycleSpeed / 50
      else frontCycle = 0
      frontCycle %= 360

      let temp = engine.getSensorValue(userSensor1)
      gSensor += ((temp.value / (temp.max - temp.min)) - gSensor) / 30
      
      DrawRect(0, 0, 500, 500, getColorString(proBack[0], proBack[1], proBack[2], backFade / 3000))
      effects.forEach((ele, i) => {
        ele.draw()
        if(ele.lifetime <= 0){
          effects.splice(i, 1)
        }
      })
      ctx.drawImage(hiddenCanvas, 0, 0)

  
      window.requestAnimationFrame(update);
    };

    var beachColor = [[203, 68, 84], [186, 94, 44], [180, 81, 73], [45, 47, 44], [28, 67, 85], [151, 94, 75]];
    var retroColor = [[349, 100, 46], [41, 100, 55], [58, 100, 30], [199, 36, 46], [221, 100, 19], [3, 100, 36]];
    var rainbowColor = [[0, 100, 50], [35, 100, 50], [60, 100, 50], [120, 100, 50], [220, 100, 50], [270, 100, 50]];
    var spaceColor = [[293, 84, 90], [271, 71, 36], [280, 81, 18], [269, 70, 26], [230, 42, 41], [218, 100, 47]];
    var mondrianColor = [[60, 100, 50], [60, 100, 50], [270, 100, 100], [220, 100, 50], [0, 100, 50], [35, 100, 100]];
    var vaporwaveColor = [[271, 89, 64], [242, 80, 75], [185, 41, 57], [298, 100, 71], [299, 93, 78], [49, 85, 65]]
    var outrunColor = [[286, 46, 22], [340, 67, 59], [49, 78, 62], [30, 78, 56], [227, 51, 56], [224, 77, 70]];
    var kawaiiColor = [[183, 100, 87], [171, 100, 94], [316, 100, 93], [203, 100, 85], [274, 100, 89], [0, 100, 100]];
    var oceanColor = [[193, 44, 17], [195, 31, 52], [194, 42, 30], [197, 45, 45], [193, 40, 70], [190, 50, 90]];
    var cottagecoreColor = [[276, 16, 37], [35, 54, 56], [61, 35, 37], [105, 11, 37],[28, 40, 49], [40, 92, 85]];
    var summerColor = [[280, 16, 25], [10, 79, 64], [19, 84, 75], [60, 75, 68], [350, 38, 64], [265, 19, 44]];
    var contemporaryColor = [[210, 76, 23], [43, 100, 50], [195, 57, 53], [9, 82, 57], [22, 81, 78], [178, 45, 53]]
    var tetrisColor = [[218, 97, 35], [218, 97, 35], [97, 58, 51], [50, 100, 50], [33, 100, 55], [8, 100, 54]];
    let colors = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]

    function oncolorModeChanged(){
        switch(colorMode){
          case "Rainbow Gradient":
            break;
          case "Beach":
            colors = beachColor
            break;
          case "Retro":
            colors = retroColor
            break;
          case "Rainbow":
            colors = rainbowColor
            break;
          case "Space":
            colors = spaceColor
            break;
          case "Mondrian":
            colors = mondrianColor
            break;
          case "Vaporwave":
            colors = vaporwaveColor
            break;
          case "Outrun":
            colors = outrunColor
            break;
          case "Kawaii":
            colors = kawaiiColor
            break;
          case "Ocean":
            colors = oceanColor
            break;
          case "Cottagecore":
            colors = cottagecoreColor
            break;
          case "Summer":
            colors = summerColor
            break;
          case "Tetris":
            colors = tetrisColor
            break;
          case "Contemporary":
            colors = contemporaryColor
            break;
        }
    }

    let proBack = [240, 100, 50]
    function onbackColorChanged(){
      proBack = hexToHSL(backColor)
    }

    let proCustom = [240, 0, 0]
    function oncustomColorChanged(){
      proCustom = hexToHSL(customColor)
    }

    let proTap = [190, 0, 0]
    function ontapColorChanged(){
      proTap = hexToHSL(tapColor)
    }

    function drawDots(hue){
      this.dotCount = 1
      this.alpha = 0
      this.half = false
      this.draw = function(){
        this.hue = colorMode == "Sensor Data" ? gSensor * 120 + proCustom[0] : hue ? hue : proCustom[0]
        let tempSpeed = colorMode == "Sensor Data" ? gSensor * 100 : speed;
        for(let i = 0; i < this.dotCount; i++){
          let tI
          if(i == 0) tI = .5
          else tI = i
          let r = 15 * Math.sqrt(tI)
          let rot = tI * 2.4
          let x = Math.cos(rot) * r + 160
          let y = Math.sin(rot) * r + 100
          let radius = 40 * (this.dotCount - tI) / this.dotCount
          let hue, tempSpeed
          if(colorMode == "Custom" || colorMode == "Sensor Data"){
            this.hue = gSensor * 120 + proCustom[0]
            tempSpeed = gSensor * 100
            hue = radius * colorRange / 10
            DrawCircle(x, y, radius, getColorString(hue + this.hue + frontCycle, proCustom[1], proCustom[2], this.alpha))
          } else {
            this.hue = hue ? hue : proCustom[0]
            tempSpeed = speed
            hue = Math.floor(i / this.dotCount * 6)
            DrawCircle(x, y, radius, getColorString(colors[hue][0] + frontCycle, colors[hue][1], colors[hue][2], this.alpha))
          }
        }
        if(this.dotCount < 250) {
          this.dotCount += tempSpeed / 50 * (this.dotCount / 150)
          if(this.alpha < 1) this.alpha += tempSpeed / 50000
        }
        else {
          if(!this.half){
            this.half = true
            let temp = this.hue + 40 * colorRange / 10
            temp%=360
            effects.push(new drawDots(this.hue + temp))
          }
          this.dotCount < 350 ? this.dotCount += tempSpeed / 50 : this.lifetime = 0
        }
      }
    }

    function keyTap(x, y){
      this.x = x
      this.y = y
      this.dotCount = Math.random() * 10
      this.draw = function(){
        let tempSpeed = colorMode == "Sensor Data" ? gSensor * 100 : speed;
          let tI
          if(this.dotCount == 0) tI = .5
          else tI = this.dotCount
          let r = 15 * Math.sqrt(tI)
          let rot = tI * 2.4
          let x = Math.cos(rot) * r + this.x
          let y = Math.sin(rot) * r + this.y
          effects.push(new keyDot(x, y))
        if(this.dotCount < 250) this.dotCount += tempSpeed / 5
        else this.dotCount < 350 ? this.dotCount += tempSpeed / 5 : this.lifetime = 0
      }
    }

    function keyDot(x, y){
      this.x = x
      this.y = y
      this.rad = 1
      this.alpha = 1
      this.cycle = frontCycle
      this.draw = function(){
        DrawCircle(this.x, this.y, this.rad, getColorString(proTap[0] + this.cycle, proTap[1], proTap[2], 1 - this.rad / 25))
        this.rad < 25 ? this.rad ++ : this.lifetime = 0
      }
    }

    function getColorString(hue, sat, lit, alpha) {
        return `hsla(${hue}, ${sat}%, ${lit}%, ${alpha})`;
    }
    //#endregion

  function DrawCircle(x, y, radius, color) {
    hiddenCtx.beginPath();
    hiddenCtx.fillStyle = color;
    hiddenCtx.arc(x, y, radius, 0, 2 * Math.PI)
    hiddenCtx.fill();
  };

  function DrawRect(x, y, width, height, color) {
    hiddenCtx.beginPath();
    hiddenCtx.fillStyle = color;
    hiddenCtx.fillRect(x, y, width, height);
  };

  function hexToHSL(hex) {
      const [, r, g, b] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) || [];
      const rgb = [r, g, b].map(x => parseInt(x, 16) / 255);
      const max = Math.max(...rgb);
      const min = Math.min(...rgb);
      const l = (max + min) / 2;
      
      if (max === min) return [0, 0, Math.round(l * 100)];
      
      const d = max - min;
      const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      
      let h;
      const [nr, ng, nb] = rgb;
      if (max === nr) h = (ng - nb) / d + (ng < nb ? 6 : 0);
      else if (max === ng) h = (nb - nr) / d + 2;
      else h = (nr - ng) / d + 4;
      
      return [
        Math.round(h * 60),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    }
    
    function onCanvasTapped(x, y) {
      if(tapOn) effects.push(new keyTap(x, y))
    }
    //#endregion


  window.requestAnimationFrame(update);
</script>
